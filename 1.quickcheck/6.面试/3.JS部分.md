# 3.JS部分

---

### 题一：['1', '2', '3'].map(parseInt) what & why ? (🔥JS的映射与解析)（基本语法）

```js
正常会想是 [1, 2, 3] 其实是 [1, NaN, NaN] ？

// ❣️ map() 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 （参数一：回调中正在处理的当前元素，参数二：当前元素的索引，参数三...）
// ❣️ parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)（参数一要处理的数 | 参数二基数，默认为10，可以理解为进制）

// 正常的执行过程
['1', '2', '3'].map((item, index) => {
	return parseInt(item, index)
})
// parseInt('1', 0) // 1
// parseInt('2', 1) // NaN 没有1进制这一说，说着说 参数二的范围是 2~
// parseInt('3', 2) // NaN 二进制没有3

变式一：['10','10','10','10','10'].map(parseInt) // [10, NaN, 2, 3, 4]
变式二：怎么实现都变为数组呢？['10','10','10','10','10'].map(Number); // [10, 10, 10, 10, 10]
```


- ❣️注意：在radix为 undefined，或者radix为 0 或者没有指定的情况下，JavaScript 作如下处理：
    - 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制).
    - 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
    - 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。

---

### 题二：什么是防抖和节流？有什么区别？如何实现？（）

**防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行（例如搜索框，只有当用户搜索输入完成之后，停个零点几秒才会服务器发送请求，如果停顿的时间小于设定的，那就还不执行，这个就是防抖）**

```js
function debounce(fn) {
  let timeout = null; // 创建一个标记用来存放定时器的返回值
  return function () {
    clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
    timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
      fn.apply(this, arguments);
    }, 500);
  };
}

debounce(fn) // 使用

```

---

**节流：指定时间间隔内只会执行一次任务（例如一个一秒内连续触发的事件，如果用了节流，让其300ms触发一次，那么1s就只能触发3次）**

```js
function throttle(fn) {
  let canRun = true; // 通过闭包保存一个标记
  return function () {
    if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
    canRun = false; // 立即设置为false
    setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
      fn.apply(this, arguments);
      // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
      canRun = true;
    }, 500);
  };
}

throttle(fn) // 使用
```

[节流和防抖其他好的文章](https://juejin.im/entry/58c0379e44d9040068dc952f)

---

### 第三题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？（基本语法）

感觉理解还是似懂非懂，关键在于，我没有应用，接下来的问题，就是这几个的常见应用是什么？

[答案，但是还是似懂非懂](https://github.com/sisterAn/blog/issues/24)

---

### 第四题：介绍下深度优先遍历和广度优先遍历，如何实现？

这个还是应该部分不知道，
评论区有人说应用到了树形组件 遍历上
而且和递归的思想想结合（例如：请分别用深度优先思想和广度优先思想实现一个拷贝函数？）

**深度优先遍历DFS（与树的先序遍历比较类似）**

```js
假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止
```

**广度优先遍历BFS**

```js
从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。
```

[答案，还是不大懂](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9)


---

### 第五题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？

思想见 第四题，这块 深度优先 和 广度优先 我还没搞太懂


---

### 第六题：ES5/ES6 的继承除了写法以外还有什么区别？

- class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量（就是要先定义，才能用）
- class 声明内部会启用严格模式
- class 的所有方法（包括静态方法和实例方法）都是不可枚举的（ES5通过原型链的写法是可以枚举的）
- 必须使用 new 调用 class
- ......

**❣️ES5实现继承**

```js
// 寄生组合式继承
// 通过借用构造函数来继承属性, 通过原型链来继承方法
// 不必为了指定子类型的原型而调用父类型的构造函数,我们只需要父类型的一个副本而已
// 本质上就是使用寄生式继承来继承超类型的原型, 然后再讲结果指定给子类型的原型
function object(o){ // ===Object.create()
  function F(){};
  F.prototype = o;
  return new F();
}
function c1(name) {
  this.name = name;
  this.color = ['red', 'green'];
}
c1.prototype.sayName = function () {
  console.log(this.name);
}
function c2(name, age) {
  c1.call(this, name)
  this.age = age
}
// 第一步:创建父类型原型的一个副本
// 第二步:为创建的副本添加 constructor 属性, 从而弥补因重写原型而失去的默认的 constructor 属性
// 第三步:将新创建的对象(即副本)赋值给子类型的原型
function inheritPrototype(superType, subType) {
  const prototype = object(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}

inheritPrototype(c1, c2);
// c2的方法必须放在寄生继承之后
c2.prototype.sayAge = function () {
  console.log(this.age);
}
```

---

### 第七题：setTimeout、Promise、Async/Await 的区别（考察 宏观任务队列 微观任务队列的区别）

- 这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列
    - settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；
    - promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；
    - async 函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行

[更详细的答案](https://github.com/sisterAn/blog/issues/21)

---

### 第八题：Async/Await 如何通过同步的方式实现异步

Async/Await就是一个自执行的generate函数 利用generate函数的特性把异步的代码写成“同步”的形式。

这个要看明白 generate函数


### 第九题：异步笔试题

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

---

### 🔥第七，九 题整体总结（Event Loop）

前言介绍：我们都知道 JavaScript 是一门 单线程 语言，也就是说同一时间只能做一件事，它就像是只有一个窗口的银行，客户不得不排队一个一个的等待办理。同理 JavaScript 的任务也要一个接一个的执行，如果某个任务（比如加载高清图片）是个耗时任务，那浏览器岂不得一直卡着？为了防止主线程的阻塞，JavaScript 有了 同步 和 异步 的概念。

**数据结构**

- 栈 (stack): 后进先出，存储基本数据类型和对象的指针，有 push() 和 pop() 这两个方法
- 队列 (queue): 后进后出，有 shift() 和 unshift() 这两个方法
- 堆 (heap): 堆是基于树抽象数据类型的一种特殊的数据结构

**浏览器核心概念**

- 执行栈：当我们调用一个方法的时候，JavaScript 会生成一个与这个方法对应的执行环境，又叫执行上下文(context)。这个执行环境中保存着该方法的私有作用域、上层作用域(作用域链)、方法的参数，以及这个作用域中定义的变量和 this 的指向，而当一系列方法被依次调用的时候。由于 JavaScript 是单线程的，这些方法就会按顺序被排列在一个单独的地方，这个地方就是所谓执行栈。
- 任务队列：事件队列是一个存储着 异步任务 的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果事件队列不为空的话，事件队列便将第一个任务压入执行栈中运行。

---

**🔥解题细节收获🔥**

- 口诀：同步先执行，异步先执行微队列，再执行宏队列
- 细节点：Promise.then 才会放到微队列中 !!!（此题和上一道题简直承上启下）
- 细节点：async/await await前面的代码是同步，await后面的代码是异步（这里其实是语法糖）
- 细节点：还有就是小心 return 这个会跳出某些 .then 跑到外面的 .then 上（可能）

```js
// ================ async/await 变换前 ===============
async function foo() {
  // await 前面的代码
  await bar();
  // await 后面的代码
}

async function bar() {
  // do something...
}

foo();

// ================ async/await 变换后 ===============

function foo() {
  // await 前面的代码
  Promise.resolve(bar()).then(() => {
    // await 后面的代码
  });
}

function bar() {
  // do something...
}

foo();
```

---

**题一**

```js
function async1() {
  console.log('async1 start'); // 2

  Promise.resolve(async2()).then(() => {
    console.log('async1 end'); // 6
  });
}

function async2() {
  console.log('async2'); // 3
}

console.log('script start'); // 1

setTimeout(function() {
  console.log('settimeout'); // 8
}, 0);

async1();

new Promise(function(resolve) {
  console.log('promise1'); // 4
  resolve();
}).then(function() {
  console.log('promise2'); // 7
});
console.log('script end'); // 5

```

- 首先打印出 script start
- 接着将 settimeout 添加到宏任务队列，此时宏任务队列为 ['settimeout']
- 然后执行函数 async1，先打印出 async1 start，又因为 Promise.resolve(async2()) 是同步任务，所以打印出 async2，接着将 async1 end 添加到微任务队列，，此时微任务队列为 ['async1 end']
- 接着打印出 promise1，将 promise2 添加到微任务队列，，此时微任务队列为 ['async1 end', promise2]
- 打印出 script end
- 因为微任务优先级高于宏任务，所以先依次打印出 async1 end 和 promise2
- 最后打印出宏任务 settimeout

---

**题二**

```js
const p1 = new Promise((resolve, reject) => {
  console.log('promise1');
  resolve();
})
  .then(() => {
    console.log('then11');
    new Promise((resolve, reject) => {
      console.log('promise2');
      resolve();
    })
      .then(() => {
        console.log('then21');
      })
      .then(() => {
        console.log('then23');
      });
  })
  .then(() => {
    console.log('then12');
  });

const p2 = new Promise((resolve, reject) => {
  console.log('promise3');
  resolve();
}).then(() => {
  console.log('then31');
});
```

- 首先打印出 promise1
- 接着将 then11，promise2 添加到微任务队列，此时微任务队列为 ['then11', 'promise2']
- 打印出 promise3，将 then31 添加到微任务队列，此时微任务队列为 ['then11', 'promise2', 'then31']
- 依次打印出 then11，promise2，then31，此时微任务队列为空
- 将 then21 和 then12 添加到微任务队列，此时微任务队列为 ['then21', 'then12']
- 依次打印出 then21，then12，此时微任务队列为空
- 将 then23 添加到微任务队列，此时微任务队列为 ['then23']
- 打印出 then23

---

**题三（注意这了有处有return，是个小陷阱）**

```js
const p1 = new Promise((resolve, reject) => {
  console.log('promise1'); // 1
  resolve();
})
  .then(() => {
    console.log('then11'); // 2
    return new Promise((resolve, reject) => {
      console.log('promise2'); // 3
      resolve();
    })
      .then(() => {
        console.log('then21'); // 4
      })
      .then(() => {
        console.log('then23'); // 5
      });
  })
  .then(() => {
    console.log('then12'); //6
  });
```

---

- 推荐拓展阅读文章一：[最后一次搞懂 Event Loop](https://www.yanceyleo.com/p/5cbc0ad8ec9b0f4eac13467e)
- 推荐拓展阅读文章二：[微任务、宏任务与Event-Loop](https://juejin.im/post/5b73d7a6518825610072b42b#heading-5)

---

❣️我之前的其他解释

**JS主线程不断的循环往复的从任务队列中读取任务，执行任务，其中运行机制称为事件循环（event loop）**

- 在高层次上，JavaScript 中有 **microtasks** 和 **macrotasks（task）**，它们是异步任务的一种类型，
- Microtasks的优先级要高于macrotasks，microtasks 用于处理 I/O 和计时器等事件，每次执行一个。microtask 为 async/await 和 Promise 实现延迟执行，并在每个 task 结束时执行。在每一个事件循环之前，microtask 队列总是被清空（执行）

**他们具有的API**

- microtasks（微任务）
    - process.nextTick
    - promise
    - Object.observe (废弃)
    - MutationObserver
- macrotasks（宏任务）
    - setTimeout
    - setImmediate
    - setInterval
    - I/O
    - UI 渲染

---

**event loop 执行过程解释**

- 每一个 event loop 都有一个 microtask queue
- 每个 event loop 会有一个或多个macrotask queue ( 也可以称为task queue )
- 一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue中
- 每一次event loop，会首先执行 microtask queue， 执行完成后，会提取 macrotask queue 的一个任务加入 microtask queue， 接着继续执行microtask queue，依次执行下去直至所有任务执行结束。


---

**再次解释**

- JS 主线程拥有一个 执行栈（同步任务） 和 一个 任务队列（microtasks queue），主线程会依次执行代码
- js中为了防止线程阻塞，阻止全局代码的执行，衍生出很多异步执行解决方案，这些方案都会按需加载到指定的队列中，当全局队列执行完毕后，开始循环从 微队列->宏队列->微队列->宏队列...这种执行顺序执行下去
- 当一个宏观队列执行完毕，立刻执行最近添加的微观队列

**辅助解释参考**

- setTimeout 会被放到 macrotasks queue 里面
- Promise 会被放到 microtask queue 里面
- 每一次event loop，会首先执行 microtask queue， 执行完成后，会提取 macrotask queue 的一个任务加入 microtask queue， 接着继续执行microtask queue，依次执行下去直至所有任务执行结束。

---

**待完善...**




