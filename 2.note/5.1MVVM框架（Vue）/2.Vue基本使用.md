# 2.Vue基本使用

---

## 🥜第一部分：前言

> 我感觉Vue的官网已经很详细了，但我还是想再简化一点，作为我自己查阅使用

### 1.为什么要用Vue

> 我们有jQuery，为什么要用Vue，Vue好在哪里

- 性能更好
    - jQuery主要是操作DOM的一个库，但是操作DOM是十分消耗性能的，修改DOM会导致重绘重排
    - 而Vue使用 虚拟DOM（不是一个真实的DOM，而是由JS来模拟出来的具有真实DOM结构的一个树形结构），性能更好
    - 见 使用虚拟DOM库
- 视图，数据分离
    - 主要是模板引擎的作用，见实现一个模板引擎
- 维护成本低

---

### 2.Vue介绍

> 是一套用于构建用户界面的渐进式框架



---

### 2.虚拟DOM

> DOM的操作是昂贵的，JS的运行效率更高，将DOM对比放到JS层，减少DOM操作，效率更高

[snabbdom](https://github.com/snabbdom/snabbdom) 是一个比较火的 虚拟DOM库，Vue2.0虚拟DOM就借鉴了这个库，我可以先使用一下这个库

```html

<body>

<div id="app">
    <!-- 展示的DOM节点 -->
    <!-- <div id="my">
        <h1 class="name">朱昆鹏</h1>
        <h2>21</h2>
    </div> -->
</div>
<button id="ageAdd">年龄+1</button>

<script src="https://cdn.bootcss.com/snabbdom/0.7.3/snabbdom.min.js"></script>
<script>
    
    let app = document.getElementById('app')
    let ageAdd = document.getElementById('ageAdd')
    let data = { name: '朱昆鹏', age: 21 }
    let vNode = null;

    render() // 初次渲染

    function render () {
        const patch = snabbdom.init([])
        const h = snabbdom.h

        let newVNode = h('div#my', {}, [
            h('h1.name', {}, [data.name]),
            h('h2', {}, [data.age])
        ])
        
        // 这个其实就是会自动对比更新，不知道是否是Diff算法
        if (vNode) {
            patch(vNode, newVNode)
        } else {
            patch(app, newVNode)
        }

        vNode = newVNode
    }

    // 年龄加一点击事件
    ageAdd.onclick = function () {
        data.age += 1
        render()
    }

</script>
</body>

```

---

### 3.模板引擎解析

---

### 4.双向数据绑定实现原理

---

## 🍯第二部分：Vue基础

### 1.安装

---

### 2.创建实例

```html
<body>
    <div id="app">
        <p>姓名：{{my.name}}</p>
        <p>年龄：{{my.age}}</p>
        <p>数组：{{my.arrTest}}</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>
        
        let vm = new Vue({
            el: '#app', // 规定渲染的路径
            data: { // 插值表达式渲染的数据
                my: {
                    name: '朱昆鹏',
                    age: 21,
                    arrTest: [1,2,3]
                }
            }
        })

        // data中的数据，最后会放到 vm 上，也就是 vm.my.name 是 朱昆鹏（其实methods也会放到 vm上）

    </script>
</body>

```

---

### 3.数组，对象问题

> 2.创建实例中，有个数组的示例，但是有一些问题，其实对象也有这些问题

- vm.my.arrTest = [1,2,3,4] 没问题，可以变
- vm.my.arrTest.push(4)  没问题，可以变
- ❎ vm.my.arrTest[0] = 5 变不了
- ❎ vm.my.arrTest.length = 1 变不了

**❣️ 更新的原理是 Object.defineProperty，其实是监听不到 引用对象里面数据改变的**

**🔥 数组解决方法：也就是数组 push 也不能触发，但是Vue改写了 数组原型上的方法，这个称之为 数组变异方法，除了 push 还有 pop, shift, unfhift, sort, reverse, splice**

**🔥 对象解决方法：通过 $set(要改的是谁，要改成什么，改成什么样的的值)，一般常用于对象**

**拓展：vm.$el 表示我们那个 app 的DOM**

**拓展：vm.$nextTick() 再次渲染DOM之后的，例如vm.my.age = 23，vm.$el.innerText 其实获取的是上一个状态的，怎么才能拿到渲染之后的DOM呢，就需要 vm.$nextTick(() => {})**

**拓展：vm.$mount() 挂载元素**

---

### v-pre（会跳过模板解析过程）

```js
<div>{{name}}</div> // 输出朱昆鹏
<div v-pre>{{name}}</div> // 输出 {{name}}
```

---

### v-cloak（在模板解析之前存在，编译之后消除）

```js
// 这个有什么用呢，因为页面是先加载DOM之后，才加载JS，然后Vue才动用模板解析，进行渲染的，也就是页面有段时间，是 {{}} 这种的展示形式，这种体验不好，可以用 cloak 进行占位

// 使用方式是主要配合css进行
[v-clock] {
    display: none
}

<div id="app">
    <div v-cloak></div>
</div>
```

---

### v-once（让某个元素不再更改）

内部原理是使用了缓存

```js

<div v-once>{{name}}</div> // 朱昆鹏

// vm.name = 111 视图不变（原理是调用了缓存）
```

---

### v-html（渲染网页内容）

底层原理是innerHtml

```js

<div v-html="domData"></div> // 容易造成XSS攻击 

```

---

### v-text（渲染文本）

使用v-text的标签，内部内容都会被替换层 v-text绑定的内容，底层原理是 innerText

```js

<div v-text="age">{{name}}</div> // 21

```

---

### v-if v-else v-else-if

```js
<div v-if="isShow">示例1</div>
<template v-else-if="isShow2">示例2</template>
<template v-else>示例3</template>
<div></div>

```

---

### v-show

```js
<div v-show="isShow">示例</div>
```

---

### v-if 和 v-show的区别

- v-if 是真正让元素消失，或者插入
- v-show 是控制css，让其显示或者隐藏，并且不支持template标签

---

### v-bind（当属性想使用数据的时候）

```js
<img v-bind:src="url"></src>

// 绑定多个class :class="[class1, class2]" 或者 :class="{ class1: isClassShow1, class2: isClassShow2 }" 或者 [class1, isShow ? '' : '']
// 绑定多个style :style="[style1, style2]"，{} 和 [] 都和 绑定多个 class 一致
// :style 样式是会覆盖 style样式的
```

---

### v-on（事件，读取 methods里面的函数）

```js
<button v-on="click">点击</button>

new Vue({
    el: '#app',
    data: {},
    methods: {
        click () {
            alert('打印')
        }
    }
})
```

---

### v-for

```js

// 注意 :key 不能写到 template 上
<template v-for="(item, index) in arrData">
    <p :key="item.id">{{ index }} : {{ item }}</p>
</template>

// 拓展：还能遍历数字，字符串
<template v-for="item in 5">{{item}}</template> // 1 2 3 4 5
<template v-for="item in 'zhu'">{{ item }}</template> // z h u


```

---

### v-model（双向数据绑定）

**主要用于输入框，做了一层简单的优化，使之有双向绑定的效果，效果就是，输入框内数据改变，data中的数据也一起改变**

原理解析：监听 input 值改变事件，将改变的值，赋予 v-model 绑定的 属性，本质上是 input + value 语法糖

```js

<input v-model="name" /> // 普通输入框
<textarea v-model="text"></textarea>

<input type="checkbox" v-model="checked" /> // 单选框
// 多选框也可以，多选框 v-model 应该绑定数组格式
// 单选框也可以

// select也可以（多选将数据格式调成数组就行）
<select v-model="selected">
    <option value="" disabled>请选择</option>
    <option value="A">A</option>
    <option value="B">B</option>
    <option value="C">C</option>
</select>

```

---

### 单向数据流 和 双向数据绑定原理探索以及实现

---

### 修饰符

---

### 写一个todoList

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div id="app">

        <input type="text" v-model="task">
        <button @click="addTask($event, 'click')">提交</button>

        <p>正在添加的任务：{{task}}</p>
        <h4>所有任务</h4>
        
        <ul>
            <li v-for="(task, index) in taskList" :key="index">
                {{task}}
                <button @click="deleteTask(index)">删除</button>
            </li>
        </ul>

    </div>

    <script src="https://cn.vuejs.org/js/vue.js"></script>
    <script>

        // 自定义按键修饰符别名（键盘事件，鼠标事件, v-model等都能用修饰符）
        // Vue.config.keyCodes = {
        //     'f1-key': 112
        // }

        // 例如 v-model.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步
        // 例如 v-model.number 将输入的绑定变为数字类型
        // 例如 v-model.trim 如果要自动过滤用户输入的首尾空白字符
        
        let vm = new Vue({
            el: '#app',
            data: {
                task: '',
                taskList: []
            },
            methods: {
                addTask (e, type) {

                    // 🔥🔥🔥 这个就能传递第二个方法，很好，解决了传参同时还想要 事件对象e 的需求
                    console.log(e, type)

                    this.taskList.push(this.task)
                    this.task = ''
                },
                deleteTask (index) {
                    this.taskList.splice(index, 1)
                }
            }
        })

    </script>
</body>
</html>
```

---

## 🍖第三部分：Vue进阶

### 1.自定义指令（directive）

> 全局指令，挂载Vue构造函数中，所有实例都能使用，局部指令，挂到具体实例中

**例如我们需求是，让 input 标签 最多只能输入5个字符**

```html
<body>
    <div id="app">
        <input type="text" v-model="content" v-slice="content">
    </div>

    <script src="https://cn.vuejs.org/js/vue.js"></script>
    <script>

        Vue.directive('slice', (el, bindings, vnode) => {
            
            // console.log('el', el) // 指令所在的DOM元素
            // console.log('bindings', bindings) // 自定义指令对象数据，可以设置，传参，等等
            // console.log('vnode', vnode) // 虚拟节点

            // 获取v-slice获取的值，并截取
            const val = bindings.value.slice(0, 5)
            vnode.context.content = val


        })

        let vm = new Vue({
            el: '#app',
            data: {
                content: ''
            }
        })

    </script>
</body>
```

---

**自定义指令，参数二还能传递对象**

[官方教程...](https://cn.vuejs.org/v2/guide/custom-directive.html)


---

**局部自定义指令是需要在实例上写 directives属性**

```js
new Vue({
    el: '#app',
    directives: {}
})
```

---

### 2.自定义指令进阶

---

### 3.过滤器（filter）

> 在不改变原有数据的情况下，改变了展示的数据

```js

// 例如我们将 1000000 变为 1,000,000 这种展示形式

<div id="app">
    {{ num | toNum(2) | 过滤器二 | ...}} 
</div>

// 全局过滤器
Vue.filter('toNum', (value, times) => {
    console.log('原来的数据', value)
    console.log('参数', times)

    return 处理之后的数据
})

// ❣️ 有种函数式编程的感觉

```

[过滤器官方文档...](https://cn.vuejs.org/v2/guide/filters.html)

---

### 4.el template render

**问题一：为什么我们写到 div#app 里面的东西，就能使用 Vue的语法了？**

过程是：通过el来确定读取那个标签里面的内容（HTML字符串） ---> 生成抽象语法树（AST），其实这一步就已经将插值表达式转换了 ---> 通过render 生成 Vnode ---> 变成真是的DOM元素

**❣️ 备注：el其实还能传真实的DOM节点，如果不写el的话，会看有没有 $mount,不会解析了**

---

**如果有了 template ，那么会怎么解析呢？**

首先判断是否有 el（没有就看是否有 $mount）---> 然后判断是否有 template（没有的话 template = $el.outerHTML，也就是 el#app里面的内容）---> 生成AST ---> render ---> vnode ---> 真实DOM

---

**render ?**

```js
<body>
    <div id="app">
        <p>{{ name }}</p>
    </div>
            
    <script src="https://cn.vuejs.org/js/vue.js"></script>
    <script>

        new Vue({
            el: '#app',
            data: { name: '朱昆鹏' },
            template: '<h1>我是template，有了我，div#app里面的内容就会被我替代</h1>',
            // h 其实是 createElement
            render (h) {
                return h('h1', '我是render函数，有了我 template div#app里面的内容都被我替代，我是最后步骤')
            }
        })

    </script>
</body>

```

---

### 5.渲染函数 & JSX

[官方文档...](https://cn.vuejs.org/v2/guide/render-function.html)

---

### 6.生命周期

---

### 7.计算属性和侦听器

---

## 🍔第四部分：Vue组件

---

## 🥒第五部分：Vue-Cli

