# 7.函数式编程

::: warning
等待书写中...
:::

---

## 第一部分：函数式编程基础

::: tip
**函数式编程不是用函数来编程，也不是传统的面向过程编程。** 主要是将复杂的函数 符合成简单的函数（计算理论，递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用

举例：React高阶组件
:::

---

### 函数编程的基本概念

- 函数是第一等公民
- 只用表达式，不用语句
- 没有副作用
- 不修改状态
- 引用透明（函数运行只靠参数）

---

### 核心概念

- 纯函数
- 函数的柯里化
- 函数组合
- Point Free
- 声明式与命令式代码
- 惰性求值

---

### 纯函数

对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态

鉴于这个特性能做什么？

- 可以做缓存，因为第一次，我知道输入什么了，第二次就不用计算了，提高性能
- 纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，例如可缓存性

---

### 函数的柯里化

- 传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数
- 作用就是解决了函数不纯的问题，将函数依赖的变量以参数的形式组合成 新的函数
- 好处：事实上柯里化是一种预加载函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数。某种意义上讲，这是一种对参数的缓存，是一种非常高效的编写函数的方式

---

### 函数组合

- 将需要层层嵌套的函数 通过一个组合函数包一层，使其使用起来更舒适

---

### Point Free

- 把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量
- 例如：const f = str => str.toString().split('')

```js
// 解决
let toString = str => str.toString();
let split = str => str.split();

let fn = compost(split(' '), toString)

fn(123) // [1, 2, 3]

// 这种风格能帮助我们减少不必要的命名，让代码保持简洁和通用
```

---

### 声明式与命令式代码

- 命令式代码：我们通过编写一条又一条指令去让计算机执行一些动作，这其中会涉及到很多繁杂的细节
- 声明式代码：通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示
- 优缺点：
  - 函数式编程这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码，优化代码时，目光只需要集中在这些稳定坚固的函数内部即可
  - 不纯的函数式代码会产生副作用，或者依赖外部系统环境，使用他们的时候总要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担

---

### 惰性求值，惰性函数

- 在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于其内部的状态。因此必须顺序执行


```js
// 求累加的函数（未使用惰性函数）
function add(num) {
    let addVale = 0;
    for (let i = 0; i <= num; i++) {
        addVale += i
    }
    return addVale
}

add(2000000000) // 1s
add(2000000000) // 1s
add(2000000000) // 1s
add(2000000000) // 1s

// 总共4s
```

```js
// 求累加的函数（使用 惰性函数）
function add(num) {
    let addVale = 0;
    for (let i = 0; i <= num; i++) {
        addVale += i
    }
    // 函数函数
  	add = function () {
      addVale
    }
    return addVale
}

add(2000000000) // 1s
add(2000000000) // 0s
add(2000000000) // 0s
add(2000000000) // 0s

// 总共1s
```

---

## 第二部分：更加专业的术语

- 高阶函数
- 尾递归优化
- 闭包
- 容器，Functor
- 错误处理，Either，AP
- IO
- Monad

---

### 高阶函数

- 本来我函数不能做很复杂的事情，你给我传过来一个复杂的函数，我一组合就能干很复杂的事情了
- 将函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象。

---

### 尾递归优化

---

### 闭包

- 在函数里面返回一个函数就会造成闭包，更深层次的我好像也知道，给忘了

---

## 第三部分：流行的函数式编程库

- RxJS
- cycleJs
- **lodash.js**, lazy（惰性求值）
- underscoreJS
- ramadjs

---

### 1.RxJS（必学）

- 诞生以来一直不温不火，单它的函数响应式编程（FRP）理念非常先进（函数式编程 FP）
- 在RxJS中，所有的外部输入（用户输入，网络请求等等）都被试做一种事件流（这种机制特别适合处理游戏，上上下下）

---

### 2.lodash

---

### 3.underscoreJS（以后学）
